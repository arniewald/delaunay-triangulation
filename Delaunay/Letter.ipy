import numpy as np
import pandas as pd
import random
import matplotlib.pyplot as plt
from time import time

from functions import *
from mc_functions import *


""" 
Classes : letters
Fields : 'lettr','x-box','y-box','width','high','onpix','x-bar','y-bar','x2bar','y2bar'
"""

#Variables
classes = [0,4,8,14,20] #Classes to select
class_map = {0:0,4:1,8:2,14:3,20:4}
features = ['x-box','y-box','width','high'] #Features to select. If None, selects all features.
al = 0.1                #Factor of distance gradient
errw = 0                #Weight of error gradient. Distance gradient's weight is 1-errw
it = 100               #Number of iterations
errw = 0
rep = 0                 #NÂº of times to refine convex hull
threshold = 0.5         #Threshold at which we map the label to 1
bc_time = np.inf          #Times at which we add barycenters
mte_threshold = 0.5     #Threshold of mean training error of triangles at which we add the barycenters
ref_label = None           #Label with respect to which binarize

#Name of file in which to write results
str_features = ''
if features!=None:
    str_features = str_features.join(features)
    str_features = str_features + '_'
filename = 'Letter_errorgradient_'+str(errw)# + str_features + str(ref_label) + '_bctime' + str(bc_time) + '_th' + str(mte_threshold)           
random.seed(0)

#Extraction of data with the desired features and classes
df = pd.read_csv('data/letter.csv')
df = df[df.lettr.isin(classes)]
df = df.replace({'lettr':class_map})
if features!=None:
    df = df[features+['lettr']]
    df.drop_duplicates(inplace=True)
    data = np.array(df[features].to_numpy(), dtype = np.float64)
else:
    data = np.array(df[list(df.columns)[:-1]].to_numpy(), dtype = np.float64)
labels = np.array(df['lettr'].to_numpy(), dtype = np.float64)


dim = data.shape[1]  #Dimension of data
size = math.floor(len(data)*0.2)               #Original size of Delaunay triangulation
test_size = math.floor(len(data)*0.1)          #Size of subdata to test

data, labels, test_data, test_labels = sample_to_test(data,labels,test_size)
print('Initializing sample...')
data, labels, sample, rem, out_hull = initialize_sample(data,labels,size,dim,rep)
labels, dim_labels = reshape_labels(data,labels)
print(len(data),len(labels),len(sample),len(out_hull))

#Initial plot
colors_rem = []
colors_sample = []
for i in range(len(rem)):
    if sum(labels[rem[i],:])==0:
        colors_rem.append('r')
    elif list(labels[rem[i],:]).index(1) == 1:
        colors_rem.append('g')
    else:
        colors_rem.append('b')
for i in range(len(sample)):
    if sum(labels[sample[i],:])==0:
        colors_sample.append('r')
    elif list(labels[sample[i],:]).index(1) == 1:
        colors_sample.append('g')
    else:
        colors_sample.append('b')

fig0 =  plt.figure(figsize = (10,7))
ax0 = fig0.add_subplot(111, projection='3d')
ax0.scatter3D(data[rem][:,0],data[rem][:,1],data[rem][:,2],s=2,color=colors_rem)
ax0.scatter3D(data[sample][:,0],data[sample][:,1],data[sample][:,2],s=100,color = colors_sample)
ax0.scatter3D(data[sample[out_hull]][:,0],data[sample[out_hull]][:,1],data[sample[out_hull]][:,2],s=100,marker='x')

#First delaunayization
tri, _, e, labels[sample,:], err = mc_delaunayization2(data,sample,labels,dim,dim_labels)
colors_sample = [[min(1,labels[sample][i,0]),min(labels[sample][i,1],1),1-min(labels[sample][i,0],1)-min(1,labels[sample][i,1])] for i in range(len(sample))]
colors_sample = [[max(c[0],0),max(c[1],0),max(c[2],0)] for c in colors_sample]

fig1 =  plt.figure(figsize = (10,7))
ax1 = fig1.add_subplot(111, projection='3d')
ax1.scatter3D(data[rem][:,0],data[rem][:,1],data[rem][:,2],s=2,color=colors_rem)
ax1.scatter3D(data[sample][:,0],data[sample][:,1],data[sample][:,2],s=100,color = colors_sample)
#plot_3Ddelaunay(data,labels,sample,rem,tri,ax1)
ax1.set_title('First estimation')


#Moving points
start = time()
data, labels, sample, added, tri, e = mc_movepoints(data,labels,sample,rem,out_hull,dim,dim_labels,it,al,errw,bc_time,mte_threshold,filename=filename, test_data=test_data,real=test_labels)
end = time()
print("Total time: ",end-start)

colors = [[min(1,labels[sample][i,0]),min(labels[sample][i,1],1),1-min(labels[sample][i,0],1)-min(1,labels[sample][i,1])] for i in range(len(sample))]
colors = [[max(c[0],0),max(c[1],0),max(c[2],0)] for c in colors]

fig2 =  plt.figure(figsize = (10,7))
ax2 = fig2.add_subplot(111, projection='3d')
ax2.scatter3D(data[rem][:,0],data[rem][:,1],data[rem][:,2],s=2,color=colors_rem)
ax2.scatter3D(data[sample][:,0],data[sample][:,1],data[sample][:,2],s=100,color = colors)
ax2.set_title('After moving points')
#plot_3Ddelaunay(data,labels,sample,rem,tri,ax2)


#Test data classification
targets, errors, correct, incorrect = mc_classify(test_data, dim, tri, labels[sample,:], real=test_labels)
print(errors)
to_color = ['r','g','b','yellow','purple','pink','orange']
test_colors = []
for i in range(len(test_labels)):
    test_colors.append(to_color[int(test_labels[i])])

fig3 =  plt.figure(figsize = (10,7))
ax3 = fig3.add_subplot(111, projection='3d')
ax3.scatter3D(data[sample][:,0],data[sample][:,1],data[sample][:,2],s=10,color = colors,marker='^')
ax3.scatter3D(data[rem][:,0],data[rem][:,1],data[rem][:,2],s=1,color = colors_rem, alpha=0.1)
ax3.scatter3D(test_data[correct][:,0],test_data[correct][:,1],test_data[correct][:,2],s=100,color = [test_colors[i] for i in correct],marker='o')
ax3.scatter3D(test_data[incorrect][:,0],test_data[incorrect][:,1],test_data[incorrect][:,2],s=100,color = [test_colors[i] for i in incorrect],marker='x')
#plot_3Ddelaunay(data,labels,sample,rem,tri,ax3)
ax3.set_title('Labels estimation')
fig3.savefig('media/'+filename+'.png')


#Show all plots
plt.show()