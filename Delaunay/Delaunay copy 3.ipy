# -*- coding: utf-8 -*-
"""
Created on Sat Dec 30 15:12:37 2023

@author: arnau
"""

import numpy as np
import matplotlib.pyplot as plt
from mpl_toolkits.mplot3d import Axes3D

import sklearn
from scipy.spatial import Delaunay, ConvexHull
from scipy.optimize import nnls
import random
import quadprog
from sklearn.datasets import make_circles, make_classification, make_moons

""" import moviepy
from moviepy.editor import VideoClip
from moviepy.video.io.bindings import mplfig_to_npimage """

def initialize_sample(data,size,dim):
    length = len(data)
    hull = ConvexHull(data)
    hull = list(hull.vertices)
    sample = random.sample([i for i in range(length) if i not in hull],size)
    sample = np.concatenate([sample,hull])
    sample.sort()
    rem = [i for i in range(length) if i not in sample]
    return np.array(sample), np.array(rem), hull

def adj_matrix(tri, sample, hull): #NEEDS OPTIMIZATION
    L = len(sample)
    adj = np.zeros((L,L),dtype=int)
    for triangle in tri.simplices:
        i, j, k = triangle[0], triangle[1], triangle[2]
        if sample[i] in hull:
            adj[i,i] = 2
        if sample[j] in hull:
            adj[j,j] = 2
        if sample[k] in hull:
            adj[k,k] = 2
        adj[i,j] = 1
        adj[j,i] = 1
        adj[i,k] = 1
        adj[k,i] = 1
        adj[j,k] = 1
        adj[k,j] = 1
    return adj

def subtesselate(data,sample,rem,dim):
    
    """ 
    Builds the Delaunay triangulation from a subsample of points containing the convex hull and computes the barycentric coordinates from the other points.
    
    Args: 
        - data: original set of points.
        - size: size of the subsample of points from which to build the Delaunay triangulation less the convex hull.
        - dim: dimension of the points of data.
    
    Returns:
        - tri: Delaunay triangulation. The indexation of the vertices comes from sample, not from data.
        - sample: sample of points from which tri is build including the convex hull.
        - rem: remaining points, not used for the triangulation.
        - bc: barycentric coordinates of rem with respect to tri.
    """
    tri = Delaunay(data[sample])
    bc = []
    
    for i in rem:
        point = data[i]
        triangle = tri.find_simplex(point)
        b = tri.transform[triangle,:dim].dot(np.transpose(point - tri.transform[triangle,dim]))
        c = np.concatenate([b,[1-sum(b)]])
        to_append = np.concatenate([[int(i),int(triangle)],c])
        bc.append(np.concatenate([[int(i),int(triangle)],c]))

    return tri, bc

def calc_bc(tri, triangle, point):
    
    """
    Calculates the barycentric coordinates of a point with respect to a triangle from a triangulation.

    Args:
        - tri: triangulation from which the triangle comes.
        - triangle: vertices from which the barycentric coordinates are calculated.
        - point: point of which to calculate the barycentric coordinates.

    Returns:
        - c: barycentric coordinates of point with respect to triangle.
    """

    b = tri.transform[triangle,:2].dot(np.transpose(point - tri.transform[triangle,2]))
    c = np.concatenate([b,[1-sum(b)]])
    return c

def estimate_height(tri, point, labels):

    """
    Calculates the height/value/label of a point given the Delaunay triangulation and the labels of their points.

    Args:
        - tri: Delaunay triangulation.
        - point: point from which to estimate the value.
        - labels: values of the points of the triangulation.

    Returns:
        - label: estimated value of point.
    """

    triangle = tri.find_simplex(point)
    verts = tri.simplices[triangle]
    bc = calc_bc(tri, triangle, point)
    label = labels[verts[0]]*bc[0]+labels[verts[1]]*bc[1]+labels[verts[2]]*bc[2]
    return label

def compute_eq_parameters(data, tri, rem, sample, bc, dim):
    B = data[rem][:,dim]
    A = np.zeros((len(rem),len(sample)))
    for i in range(len(rem)):
        s, x, y, z = bc[i][1:5]
        a, b, c = tri.simplices[int(s)]
        A[i][a], A[i][b], A[i][c] = x, y, z
    return A, B

def calc_labels(data, tri, rem, sample, bc, dim):
    B = data[rem][:,dim]
    A = np.zeros((len(rem),len(sample)))
    for i in range(len(rem)):
        s, x, y, z = bc[i][1:5]
        a, b, c = tri.simplices[int(s)]
        A[i][a], A[i][b], A[i][c] = x, y, z
    sol = np.linalg.lstsq(A,B,rcond=None)
    y = sol[0]
    e = abs(np.matmul(A,y)-B)
    P = 2*np.matmul(A.transpose(),A)
    print(np.all(np.linalg.eigvals(P) > 0))
    print(np.any(np.linalg.eigvals(P) < 0))
    print(np.any(np.linalg.eigvals(P) == 0))
    q = 2*np.matmul(e.transpose(),A)
    W = np.identity(len(y))
    print(np.all(np.linalg.eigvals(W) > 0))
    h = np.zeros(len(y))
    err = quadprog.solve_qp(P, q, W, h)[0]
    return y, e, err

def f(x,y):
    """
    Example function to give values to the points.
    """
    return np.exp(-x*x)*np.cos(np.pi*y)
                
def movepoints_step(data, sample, err, adj, al): #Points should move simultaneously
    L = len(sample)
    counter = 0
    for i in range(L):
        if adj[i,i] == 0: #Check that the point is not in the convex hull
            counter += 1
            k = i
            dif = 0
            for j in range(L):
                if adj[i,j] == 1:
                    difaux = err[j]-err[i]
                    if difaux>dif:
                        k = j
                        dif = difaux
            if k != i:
                indexi, indexk = sample[i], sample[k]
                data[indexi][0] += al*(data[indexk][0]-data[indexi][0])
                data[indexi][1] += al*(data[indexk][1]-data[indexi][1])
    return None

def delaunayization(data,sample,rem,hull,size,dim):
    tri, bc = subtesselate(data[:,0:dim],sample,rem,dim)
    adj = adj_matrix(tri,sample,hull)
    A, B = compute_eq_parameters(data, tri, rem, sample, bc, dim)
    P = 2*np.matmul(A.transpose(),A)
    print(np.linalg.matrix_rank(P))
    t = 0

    while np.all(np.linalg.eigvals(P)) <= 0:
        t += 1
        sample, rem, hull = initialize_sample(data[:,0:dim],size,dim)
        tri, bc = subtesselate(data[:,0:dim],sample,rem,dim)
        adj = adj_matrix(tri,sample,hull)
        A, B = compute_eq_parameters(data, tri, rem, sample, bc, dim)
        P = 2*np.matmul(A.transpose(),A)
        rank = np.linalg.matrix_rank(P)
        print("Not convex: t=",t," rank = ",rank, " size = ",len(sample), "len_hull = ",len(hull))
        
    sol = np.linalg.lstsq(A,B,rcond=None)
    y = sol[0]
    e = abs(np.matmul(A,y)-B)
    q = 2*np.matmul(e.transpose(),A)
    W = np.identity(len(y))
    h = np.zeros(len(y))
    #err = quadprog.solve_qp(P, q, W, h)[0]
    err = nnls(A,e)[0]
    return tri, sample, rem, adj, bc, y, e, err

def movepoints(data,sample,rem,hull,size,dim,time):
    for i in range(time):
        try:
            tri, sample, rem, adj, bc, y, e, err = delaunayization(data,sample,rem,hull,size,dim)
            print(sum(err))
            movepoints_step(data, sample, err, adj, al)
        except Exception as e:
            print(e)
    tri, sample, rem, adj, bc, y, e, err = delaunayization(data,sample,rem,hull,size,dim)
    return tri, sample, rem, adj, bc, y, e, err

#IGNORE
""" def quadprog_solve_qp(P, q, G, h, A=None, b=None): #0.5xT*P*x + qT*x s.t. Gx<=h; Ax = b
    qp_G = .5 * (P + P.T)   # make sure P is symmetric
    qp_a = -q
    if A is not None:
        qp_C = -np.vstack([A, G]).T
        qp_b = -np.hstack([b, h])
        meq = A.shape[0]
    else:  # no equality constraint
        qp_C = -G.T
        qp_b = -h
        meq = 0
    return quadprog.solve_qp(qp_G, qp_a, qp_C, qp_b, meq)[0] """

dim = 2
n_samples = 10000
size = 100
al = 0.1
time = 20

data, labels = make_classification(n_samples=n_samples)
data_aux = []
for i in range(len(data)):
    data_aux.append([data[i][j] for j in range(dim)])
    data_aux[i].append(f(data_aux[i][0],data_aux[i][1]))
data = np.array(data_aux)

sample, rem, hull = initialize_sample(data[:,0:dim],size,dim)
tri, sample, rem, adj, bc, y, e, err = delaunayization(data,sample,rem,hull,size,dim)

fig0 = plt.figure()
ax0 = fig0.add_subplot()
ax0.triplot(data[sample][:,0],data[sample][:,1],tri.simplices,color = "red")
ax0.scatter(data[sample][:,0],data[sample][:,1],s=[100*i for i in err],color = "red")
ax0.scatter(data[rem][:,0],data[rem][:,1],s=2,alpha=0.1,color='black')

tri, sample, rem, adj, bc, y, e, err =  movepoints(data,sample,rem,hull,size,dim,time)

ax0.triplot(data[sample][:,0],data[sample][:,1],tri.simplices,color = "blue")
ax0.scatter(data[sample][:,0],data[sample][:,1],s=[100*i for i in err],color = "blue")
ax0.scatter(data[rem][:,0],data[rem][:,1],s=2,alpha=0.1,color='black')
plt.show()

fig =  plt.figure(figsize = (10,7))
ax = fig.add_subplot(111, projection='3d')
my_cmap = plt.cm.jet
sct = ax.scatter3D(data[rem][:,0],data[rem][:,1],data[rem][:,dim],s=2,alpha=0.1,color='black')
ax.scatter3D(data[sample][:,0],data[sample][:,1],y,s=[100*i for i in err],color = "red")
#ax.triplot(data[sample][:,0],data[sample][:,1],tri.simplices,color = "green")
#ax.scatter(data[sample][:,0],data[sample][:,1],np.zeros(len(sample)),marker='x',color = "green")
ax.plot_trisurf(data[sample][:,0],data[sample][:,1],y, triangles=tri.simplices, alpha=0.5)
plt.show()