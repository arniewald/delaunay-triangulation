import numpy as np
import matplotlib.pyplot as plt
from mpl_toolkits.mplot3d import Axes3D

import sklearn
from sklearn.datasets import make_circles, make_classification, make_moons

import moviepy
from moviepy.editor import VideoClip
from moviepy.video.io.bindings import mplfig_to_npimage

from functions import *



dim = 2
n_samples = 10000
size = 100
al = 0.1
errw = 0.5
duration = 5

data, labels = make_classification(n_samples=n_samples)
data_aux = []
for i in range(len(data)):
    data_aux.append([data[i][j] for j in range(dim)])
    data_aux[i].append(f(data_aux[i][0],data_aux[i][1]))
data = np.array(data_aux)


old_data, data, sample, rem, in_hull = initialize_sample(data,size,dim)

fig, ax = plt.subplots()

def make_frame(t):
     
    # clear
    ax.clear()

    tri, bc = subtesselate(data[:,0:dim],sample,rem,dim)
    adj = adj_matrix(tri,sample,in_hull)
    A, B = compute_eq_parameters(data, tri, rem, sample, bc, dim)
    P = 2*np.matmul(A.transpose(),A)
    sol = np.linalg.lstsq(A,B,rcond=None)
    y = sol[0]
    e = abs(np.matmul(A,y)-B)
    err = nnls(A,e)[0]
    
    

    L = len(sample)
    incrs = np.zeros((L,2))
    counter = 0
    for i in range(L):
        if adj[i,i] == 0: #Check that the point is not in the convex hull
            counter += 1
            k1, k2 = i, i
            diferr = 0
            difdis = 0
            for j in range(L):
                if adj[i,j] == 1:
                    difauxerr = err[j]-err[i]
                    difauxdis = (data[sample[i]][0]-data[sample[j]][0])**2+(data[sample[i]][1]-data[sample[j]][1])**2
                    if difauxerr>diferr:
                        k1 = j
                        diferr = difauxerr
                    if difauxdis>difdis:
                        k2 = j
                        difdis = difauxdis
            indexi = sample[i]
            if k1 != i:
                indexk1 = sample[k1]
                incrs[i,0] += al*errw*(data[indexk1][0]-data[indexi][0])
                incrs[i,1] += al*errw*(data[indexk1][1]-data[indexi][1])
            indexk2 = sample[k2]
            incrs[i,0] += al*(1-errw)*(data[indexk2][0]-data[indexi][0])
            incrs[i,1] += al*(1-errw)*(data[indexk2][1]-data[indexi][1])

    for i in range(L):
        data[sample[i]][0] += incrs[i][0]
        data[sample[i]][1] += incrs[i][1]

    ax.triplot(data[sample][:,0],data[sample][:,1],tri.simplices,color = "red")
    ax.scatter(data[sample][:,0],data[sample][:,1],s=[100*i for i in err],color = "red")
    ax.scatter(data[rem][:,0],data[rem][:,1],s=2,alpha=0.1,color='black')
    for i in range(len(sample)):
        plt.arrow(data[sample[i]][0],data[sample[i]][1],incrs[i][0], incrs[i][1], 
        shape='full', color='b', lw =1, length_includes_head=True, 
        zorder=0, head_length=0.15, head_width=0.15)

    ax.set_title(str(t))
    # returning numpy image
    return mplfig_to_npimage(fig)
 
# creating animation
animation = VideoClip(make_frame, duration = duration)
 
animation.write_videofile("moving_points_errw1.webm",fps=5)
""" # displaying animation with auto play and looping
animation.ipython_display(fps = 20, loop = True, autoplay = True) """